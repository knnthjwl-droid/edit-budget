<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Facebook API Rate Limit Handler</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            background-color: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        .card {
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            border: none;
        }
        .terminal {
            background-color: #2d3748;
            color: #cbd5e0;
            font-family: 'Courier New', monospace;
            height: 300px;
            overflow-y: auto;
            padding: 15px;
            border-radius: 5px;
        }
        .text-info { color: #63b3ed !important; }
        .text-success { color: #68d391 !important; }
        .text-warning { color: #faf089 !important; }
        .text-danger { color: #fc8181 !important; }
        .text-secondary { color: #a0aec0 !important; }
        .status-card {
            transition: all 0.3s ease;
        }
        .progress {
            height: 8px;
        }
        .api-call-btn {
            position: relative;
            overflow: hidden;
        }
        .btn-spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            vertical-align: -0.125em;
            border: 0.2em solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            animation: spinner-border 0.75s linear infinite;
            margin-right: 0.5rem;
        }
        @keyframes spinner-border {
            to { transform: rotate(360deg); }
        }
        .rate-limit-indicator {
            background: linear-gradient(90deg, #fc8181, #faf089, #68d391);
            height: 4px;
            border-radius: 2px;
            margin-top: 5px;
        }
        .token-status {
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #f8f9fa;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">Facebook API Rate Limit Handler</h1>
        
        <div class="row">
            <div class="col-md-6">
                <div class="card status-card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">API Status</h5>
                    </div>
                    <div class="card-body">
                        <div class="d-flex justify-content-between align-items-center mb-3">
                            <div class="token-status">
                                <small>Access Token:</small>
                                <span id="tokenStatus">Unknown</span>
                                <i class="fas fa-question-circle text-secondary ms-1"></i>
                            </div>
                            <div>
                                <span class="badge bg-secondary" id="rateLimitStatus">Normal</span>
                            </div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Rate Limit Indicator</label>
                            <div class="rate-limit-indicator" id="rateLimitIndicator"></div>
                            <div class="form-text">Shows current rate limit pressure (red = high)</div>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Requests in last minute: <span id="requestCount">0</span></label>
                            <div class="progress">
                                <div id="requestProgress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>

                        <div class="mb-3">
                            <label class="form-label">Queue Status: <span id="queueCount">0</span> requests waiting</label>
                            <div class="progress">
                                <div id="queueProgress" class="progress-bar bg-info" role="progressbar" style="width: 0%"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header bg-white">
                        <h5 class="mb-0">API Controls</h5>
                    </div>
                    <div class="card-body">
                        <div class="d-grid gap-2">
                            <button id="testApiBtn" class="btn btn-primary api-call-btn">
                                <i class="fas fa-bolt"></i> Test API Connection
                            </button>
                            <button id="multiRequestBtn" class="btn btn-outline-primary api-call-btn">
                                <i class="fas fa-sync"></i> Simulate Multiple Requests
                            </button>
                            <button id="clearCacheBtn" class="btn btn-outline-secondary">
                                <i class="fas fa-trash-alt"></i> Clear Cache
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-6">
                <div class="card">
                    <div class="card-header bg-white d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">API Terminal</h5>
                        <button id="clearTerminalBtn" class="btn btn-sm btn-outline-secondary">
                            <i class="fas fa-eraser"></i> Clear
                        </button>
                    </div>
                    <div class="card-body">
                        <div id="terminalOutput" class="terminal"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="card mt-4">
            <div class="card-header bg-white">
                <h5 class="mb-0">Rate Limit Handling Strategy</h5>
            </div>
            <div class="card-body">
                <ul>
                    <li><strong>Exponential Backoff</strong>: When a rate limit error is detected, the system automatically retries with increasing delays</li>
                    <li><strong>Request Throttling</strong>: Limits the number of API calls made within a specific time window</li>
                    <li><strong>Response Caching</strong>: Stores API responses to avoid making identical requests</li>
                    <li><strong>Queue System</strong>: API requests are queued and processed in a controlled manner</li>
                    <li><strong>Visual Feedback</strong>: The interface shows current rate limit status and request counts</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const ACCESS_TOKEN = "EAAVh7S68SHwBO8ZArr36QWRDZA2kZCVvZBWIx5m8xFxKEtxev7iiyFX5YhaIZCNbhkstI31Iqt17K2H0OvTZC1QxexrfCZBMKpes9VVxstemgQ2V4dEgXkL5NWdMmJgxg561XTZCurEINASPLaVkfxZBZAqcVUD0zaj37DDfucPBIdEn9r8Rp9GKBALlLSsDE5plVfXLuQG35X";
        const RATE_LIMIT_THRESHOLD = 10; // Max requests per minute
        const CACHE_DURATION = 300000; // 5 minutes in milliseconds

        // State management
        const apiState = {
            requestQueue: [],
            requestTimestamps: [],
            isProcessingQueue: false,
            cache: new Map(),
            backoffCount: 0,
            maxBackoff: 5
        };

        // DOM Elements
        const TERMINAL = document.getElementById("terminalOutput");
        const tokenStatusEl = document.getElementById("tokenStatus");
        const rateLimitStatusEl = document.getElementById("rateLimitStatus");
        const rateLimitIndicatorEl = document.getElementById("rateLimitIndicator");
        const requestCountEl = document.getElementById("requestCount");
        const requestProgressEl = document.getElementById("requestProgress");
        const queueCountEl = document.getElementById("queueCount");
        const queueProgressEl = document.getElementById("queueProgress");
        const testApiBtn = document.getElementById("testApiBtn");
        const multiRequestBtn = document.getElementById("multiRequestBtn");
        const clearCacheBtn = document.getElementById("clearCacheBtn");
        const clearTerminalBtn = document.getElementById("clearTerminalBtn");

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            bindEvents();
            logToTerminal("System initialized. Ready to make API requests.", "INFO");
            updateRateLimitIndicator();
        });

        // Event binding
        function bindEvents() {
            testApiBtn.addEventListener('click', () => {
                testApiBtn.classList.add('disabled');
                testApiBtn.innerHTML = '<span class="btn-spinner"></span> Testing...';
                
                checkAccessToken(ACCESS_TOKEN).finally(() => {
                    setTimeout(() => {
                        testApiBtn.classList.remove('disabled');
                        testApiBtn.innerHTML = '<i class="fas fa-bolt"></i> Test API Connection';
                    }, 1000);
                });
            });
            
            multiRequestBtn.addEventListener('click', simulateMultipleRequests);
            clearCacheBtn.addEventListener('click', clearCache);
            clearTerminalBtn.addEventListener('click', clearTerminal);
            
            // Simulate periodic API calls to show rate limiting in action
            setInterval(updateRateLimitIndicator, 2000);
            setInterval(processQueue, 1000);
        }

        // Helper function to get current time as HH:MM:SS
        function getCurrentTime() {
            const now = new Date();
            return now.toLocaleTimeString('en-US', { hour12: false });
        }

        // Formal logging function
        function logToTerminal(message, level = "INFO") {
            const colors = {
                INFO: "text-secondary",
                SUCCESS: "text-success",
                ERROR: "text-danger",
                WARNING: "text-warning"
            };
            const p = document.createElement("p");
            p.className = `m-1 ${colors[level] || colors.INFO}`;
            p.textContent = `[${getCurrentTime()}] [${level}] ${message}`;
            TERMINAL.appendChild(p);
            TERMINAL.scrollTop = TERMINAL.scrollHeight;
        }

        // Clear terminal
        function clearTerminal() {
            TERMINAL.innerHTML = '';
            logToTerminal("Terminal cleared", "INFO");
        }

        // Clear cache
        function clearCache() {
            apiState.cache.clear();
            logToTerminal("API cache cleared", "INFO");
        }

        // Update rate limit indicator
        function updateRateLimitIndicator() {
            // Calculate requests in the last minute
            const oneMinuteAgo = Date.now() - 60000;
            const recentRequests = apiState.requestTimestamps.filter(timestamp => timestamp > oneMinuteAgo);
            const requestCount = recentRequests.length;
            
            // Update UI
            requestCountEl.textContent = requestCount;
            const percent = Math.min(100, (requestCount / RATE_LIMIT_THRESHOLD) * 100);
            requestProgressEl.style.width = `${percent}%`;
            
            // Update progress bar color based on usage
            if (percent < 60) {
                requestProgressEl.className = "progress-bar bg-success";
            } else if (percent < 85) {
                requestProgressEl.className = "progress-bar bg-warning";
            } else {
                requestProgressEl.className = "progress-bar bg-danger";
            }
            
            // Update rate limit indicator
            const indicatorPercent = Math.min(100, percent);
            rateLimitIndicatorEl.style.background = `linear-gradient(90deg, #fc8181 0%, #faf089 ${indicatorPercent}%, #68d391 ${indicatorPercent}%)`;
            
            // Update rate limit status text
            if (percent < 60) {
                rateLimitStatusEl.className = "badge bg-success";
                rateLimitStatusEl.textContent = "Normal";
            } else if (percent < 85) {
                rateLimitStatusEl.className = "badge bg-warning";
                rateLimitStatusEl.textContent = "Moderate";
            } else {
                rateLimitStatusEl.className = "badge bg-danger";
                rateLimitStatusEl.textContent = "High";
            }

            // Update queue status
            queueCountEl.textContent = apiState.requestQueue.length;
            const queuePercent = Math.min(100, (apiState.requestQueue.length / 10) * 100);
            queueProgressEl.style.width = `${queuePercent}%`;
        }

        // Exponential backoff delay
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Process the request queue
        async function processQueue() {
            if (apiState.isProcessingQueue || apiState.requestQueue.length === 0) return;
            
            apiState.isProcessingQueue = true;
            
            // Check if we've exceeded rate limits
            const oneMinuteAgo = Date.now() - 60000;
            const recentRequests = apiState.requestTimestamps.filter(timestamp => timestamp > oneMinuteAgo);
            
            if (recentRequests.length >= RATE_LIMIT_THRESHOLD) {
                logToTerminal(`Rate limit approaching. Delaying queue processing.`, "WARNING");
                apiState.isProcessingQueue = false;
                return;
            }
            
            const nextRequest = apiState.requestQueue.shift();
            updateRateLimitIndicator();
            
            try {
                const result = await executeApiRequest(nextRequest.url, nextRequest.options, nextRequest.retryCount);
                nextRequest.resolve(result);
            } catch (error) {
                nextRequest.reject(error);
            }
            
            apiState.isProcessingQueue = false;
        }

        // Execute API request with retry logic
        async function executeApiRequest(url, options = {}, retryCount = 0) {
            // Check cache first
            const cacheKey = `${url}-${JSON.stringify(options)}`;
            const cached = apiState.cache.get(cacheKey);
            
            if (cached && (Date.now() - cached.timestamp < CACHE_DURATION)) {
                logToTerminal(`Returning cached response for: ${url}`, "INFO");
                return cached.data;
            }
            
            // Make API request
            try {
                apiState.requestTimestamps.push(Date.now());
                updateRateLimitIndicator();
                
                const response = await fetch(url, options);
                const data = await response.json();
                
                if (data.error) {
                    if (data.error.code === 4 || data.error.is_transient) {
                        // Rate limit error - implement exponential backoff
                        if (retryCount < apiState.maxBackoff) {
                            const backoffDelay = Math.pow(2, retryCount) * 1000;
                            logToTerminal(`Rate limited. Retrying in ${backoffDelay/1000} seconds... (${retryCount + 1}/${apiState.maxBackoff})`, "WARNING");
                            await delay(backoffDelay);
                            return executeApiRequest(url, options, retryCount + 1);
                        } else {
                            throw new Error(`Exceeded maximum retry attempts after rate limit error: ${data.error.message}`);
                        }
                    } else {
                        throw new Error(`API Error: ${data.error.message}`);
                    }
                }
                
                // Cache successful response
                apiState.cache.set(cacheKey, {
                    data: data,
                    timestamp: Date.now()
                });
                
                return data;
            } catch (error) {
                logToTerminal(`API call failed: ${error.message}`, "ERROR");
                throw error;
            }
        }

        // Rate-limited API call function
        function rateLimitedApiCall(url, options = {}) {
            return new Promise((resolve, reject) => {
                apiState.requestQueue.push({
                    url,
                    options,
                    resolve,
                    reject,
                    retryCount: 0
                });
                updateRateLimitIndicator();
                processQueue();
            });
        }

        // Function to check access token validity with rate limiting
        async function checkAccessToken(token) {
            logToTerminal("Starting access token validation...", "INFO");
            tokenStatusEl.innerHTML = 'Checking... <i class="fas fa-sync-alt fa-spin ms-1"></i>';

            try {
                const data = await rateLimitedApiCall(`https://graph.facebook.com/debug_token?input_token=${token}&access_token=${token}`);
                
                if (data.data && data.data.is_valid) {
                    tokenStatusEl.innerHTML = 'Connected <i class="fas fa-check-circle text-success ms-1"></i>';
                    logToTerminal("Access token is valid.", "SUCCESS");
                    logToTerminal(`App ID: ${data.data.app_id}`, "INFO");
                    logToTerminal(`Token expires at: ${new Date(data.data.expires_at * 1000).toLocaleString()}`, "INFO");
                    return true;
                } else {
                    tokenStatusEl.innerHTML = 'Invalid <i class="fas fa-times-circle text-danger ms-1"></i>';
                    logToTerminal("Access token is invalid.", "ERROR");
                    return false;
                }
            } catch (error) {
                tokenStatusEl.innerHTML = 'Error <i class="fas fa-exclamation-circle text-warning ms-1"></i>';
                logToTerminal(`Error checking token: ${error.message}`, "ERROR");
                return false;
            }
        }

        // Simulate multiple requests to demonstrate rate limiting
        async function simulateMultipleRequests() {
            multiRequestBtn.classList.add('disabled');
            multiRequestBtn.innerHTML = '<span class="btn-spinner"></span> Making requests...';
            
            logToTerminal("Simulating multiple API requests...", "INFO");
            
            for (let i = 1; i <= 15; i++) {
                setTimeout(async () => {
                    try {
                        logToTerminal(`Queueing request ${i}/15...`, "INFO");
                        await rateLimitedApiCall(`https://graph.facebook.com/debug_token?input_token=${ACCESS_TOKEN}&access_token=${ACCESS_TOKEN}`);
                    } catch (error) {
                        // Errors are already logged by rateLimitedApiCall
                    }
                    
                    if (i === 15) {
                        setTimeout(() => {
                            multiRequestBtn.classList.remove('disabled');
                            multiRequestBtn.innerHTML = '<i class="fas fa-sync"></i> Simulate Multiple Requests';
                            logToTerminal("All requests completed", "INFO");
                        }, 1000);
                    }
                }, i * 300);
            }
        }

        // Get access token info with retry logic
        async function getAccessTokenInfo(token) {
            try {
                const data = await rateLimitedApiCall(`https://graph.facebook.com/debug_token?input_token=${token}&access_token=${token}`);
                
                if (data.error) throw data.error;

                if (data.data?.is_valid) {
                    const userData = await rateLimitedApiCall(`https://graph.facebook.com/me?access_token=${token}&fields=name,id`);
                    return { isValid: true, fbName: userData.name, fbId: userData.id };
                } else {
                    return { isValid: false, fbName: null, fbId: null };
                }
            } catch (error) {
                logToTerminal(`Error getting token info: ${error.message}`, "ERROR");
                return { isValid: false, fbName: null, fbId: null };
            }
        }
    </script>
</body>
</html>